.include "MACROSv21.s"

.data
# ABERTURA
.include "./script/Imagens/arquivos .data/tema_jogo_imagem.s"
# FINAL
.include "./script/Imagens/arquivos .data/final.data"

# MÚSICA ABERTURA
TAMANHO: .word 73
NOTAS: 60,441,64,441,60,1764,64,294,64,294,65,441,64,441,62,294,60,294,62,441,64,441,62,1764,62,294,62,294,62,294,64,294,62,294,60,588,60,441,64,441,60,1764,64,294,64,294,65,441,64,294,62,441,60,294,62,441,64,441,62,1764,62,294,62,294,62,147,64,294,62,441,60,294,53,294

# MAPA
.include "./script/Imagens/arquivos .data/ideia_fase1.data"
.include "./script/Imagens/arquivos .data/ideia_fase2.data"
.include "./script/Imagens/arquivos .data/ideia_fase3.data"
.include "./script/Imagens/arquivos .data/fundo.data"
.include "matriz1.s"
.include "matriz2.s"
.include "matriz3.s"

# PERSONAGEM PRINCIPAL
.include "./script/Imagens/arquivos .data/personagem_a.data"
.include "./script/Imagens/arquivos .data/personagem_d.data"
.include "./script/Imagens/arquivos .data/personagem_w.data"
.include "./script/Imagens/arquivos .data/personagem_s.data"

# INIMIGO
.include "./script/Imagens/arquivos .data/cogumelo_s.data"
.include "./script/Imagens/arquivos .data/cogumelo_w.data"
.include "./script/Imagens/arquivos .data/cogumelo_a.data"
.include "./script/Imagens/arquivos .data/cogumelo_d.data"

# ATAQUES
.include "./script/Imagens/arquivos .data/tiro_a.data"
.include "./script/Imagens/arquivos .data/tiro_d.data"
.include "./script/Imagens/arquivos .data/tiro_w.data"
.include "./script/Imagens/arquivos .data/tiro_s.data"

# ITENS
.include "./script/Imagens/arquivos .data/chave.data"
.include "./script/Imagens/arquivos .data/moeda.data"

#####################################
#		MACROS		    #
#####################################
.macro coleta_chave()
.text
#coleta_chave()
		addi s6, s6, 1		# incrementa-se as chaves, toda vez que entra nessa label
		li a7,101		# chamada para printar inteiro 	        	 
		mv a0, s6		# coloca as chaves no registrador a0      
		li a1,255		# coluna
		li a2,140 		# linha
		li a3,0x00a0		# cor
		li a4,0			# frame 0
		ecall
		li a7,101        	# '' 
		mv a0, s6    		# '' 
		li a1,255		# '' 
		li a2,140		# ''  
		li a3,0x00a0		# '' 
		li a4,1			# frame 1
		ecall
		li a0,87			# nota
		li a1,350			# duração
		li a2,112			# define o instrumento
		li a3,127			# define o volume
		li a7,33			# define a syscall
		ecall
.end_macro

.macro coleta_moeda()
.text
		addi s5, s5, 100	# incrementa-se a pontuação, toda vez que entra nessa label
		li a7,101       	# chamada para printar inteiro 	 
		mv a0, s5 		# coloca a pontuação no registrador a0
		li a1,260		# coluna
		li a2,80		# linha
		li a3,0x0090		# cor
		li a4,0			# frame 0
		ecall
		li a7,101        	# ''
		mv a0, s5		# ''   
		li a1,260		# ''
		li a2,80		# ''
		li a3,0x0090		# ''
		li a4,1			# frame 1
		ecall
		
		# Efeito Sonoro da coleta de moedas
		li a0,88			# nota
		li a1,370			# duração
		li a2,8			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,370			# duração
		li a2,8				# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,88			# nota
		li a1,370			# duração
		li a2,8			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
.end_macro
		
.macro fase1()
.data
# MENU 
TITULO_FASE: .string "FASE 1"
PONTOS: .string "PONTOS:"
VIDAS: .string "VIDAS:"
CHAVES: .string "CHAVES:"
NUM_CHAVES: .string "/2"

# POSIÇÕES_FASE1
CHAR_POS: .half 16,16		# posição do personagem (x,y)
OLD_CHAR_POS: .half 16,16
COG_POS: .half 64,64
OLD_COG: .half 64,64
CHAVE1: .half 192,96
CHAVE2: .half 64,160
MOEDA1: .half 112,16
MOEDA2: .half 32,208
MOEDA3: .half 48,128
.text
SETUP: 		
# Carrega a matriz da fase 1 para o registrador s1
		la s1, matriz1		
		addi s1,s1,8

# Printa a imagem do mapa 1, alternando os frames
		la a0,ideia_fase1	
		li a1,0
		li a2,0
		li a3,0
		li a4,320
		li a4,240
		call PRINT
		li a3,1
		call PRINT
# Printa o título da fase, alternando os frames 		
		li a7,104        	
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,0
		ecall
		li a7,104        
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,1
		ecall
		
# Adiciona a string dos pontos da fase, alternando os frames 
		li a7,104        
		la a0,PONTOS       
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,0
		ecall
		li a7,104        
		la a0,PONTOS        
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,1
		ecall

# Adiciona a string de chaves da fase, alternando os frames 
		li a7,104        
		la a0,CHAVES       
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,CHAVES        
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,1
		ecall
		li a7,104        
		la a0,NUM_CHAVES       
		li a1,265
		li a2,140
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,NUM_CHAVES        
		li a1,265
		li a2,140
		li a3,0x00a0
		li a4,1
		ecall

# Adiciona a string de vidas da fase, alternando os frames 
		li a7,104        
		la a0,VIDAS       
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,0
		ecall
		li a7,104        
		la a0,VIDAS        
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,1
		ecall
		
# Printa o personagem na posição inicial, alternado os frames		
		la t3,CHAR_POS		
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		la t3,CHAR_POS		
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		
# Printa as chaves e as moedas nas posições e frames corretos para a coleta	
		la t3, CHAVE1
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		la t3, CHAVE2
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		
		la t3, MOEDA1
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, MOEDA2
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,1
		call PRINT
		la t3, MOEDA3
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,1
		call PRINT
		

GAME_LOOP:	call KEY	
		j GAME_LOOP
		
		
KEY:		
# Faz a chamada do teclado e guarda a tecla pressionada no t2
		li t1,0xFF200000	
		lw t0,0(t1)
		andi t0,t0,0x0001
		beq t0,zero,FIM
		lw t2,4(t1)
		
# Compara as teclas para chamar a movimentação	
		li t0,'a'		
		beq t2,t0,CHAR_ESQ
		
		li t0,'d'
		beq t2,t0,CHAR_DIR
		
		li t0,'w'
		beq t2,t0,CHAR_CIMA
		
		li t0,'s'
		beq t2,t0,CHAR_BAIXO
		
		li t0,'e'
		beq t2,t0,DIRECAO_ATAQUE
		
		li t0, 'p'
		beq t2,t0,END

FIM:		ret

CHAR_ESQ:	la t0,CHAR_POS			
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem			
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_a
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,1				# atribui '1' ao s7 para indicar a direção (esquerda) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_DIR:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem		
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem

		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_d
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,2				# atribui '2' ao s7 para indicar a direção (direita) do personagem
	
		li t5,2			# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE	# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3			# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA	# se a nova posição do personagem for uma moeda, ocorre a coleta
		
		j GAME_LOOP

CHAR_CIMA:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem				
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		li t5,4
		beq s3,t5,VERIFICACAO_SAIDA
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,3				# atribui '3' ao s7 para indicar a direção (cima) do personagem
		
		li t5,2			# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE	# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3			# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA	# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_BAIXO:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem	
		lh t3, 2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3, 2(t1)
		sh s4,2(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_s
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,4			# atribui '4' ao s7 para indicar a direção (baixo) do personagem
	
		li t5,2			# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE	# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3			# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA	# se a nova posição do personagem for uma moeda, ocorre a coleta
		
		j GAME_LOOP
		
DIRECAO_ATAQUE:
		li t6,1			# atribui o '1' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_ESQ1	# se s7 for igual, o ataque será direcionado para esquerda, mas antes é preciso verificar se é parede
		
		li t6,2			# atribui o '2' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_DIR1	# se s7 for igual, o ataque será direcionado para direita, mas antes é preciso verificar se é parede
		
		li t6,3			# atribui o '3' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_CIMA1	# se s7 for igual, o ataque será direcionado para cima, mas antes é preciso verificar se é parede
		
		li t6,4			# atribui o '4' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_BAIXO1	# se s7 for igual, o ataque será direcionado para baixo, mas antes é preciso verificar se é parede
		
		j GAME_LOOP
		
VER_ATAQUE_ESQ1:
		la t0,CHAR_POS						
		lh t2,0(t0)		# carrega a posição do personagem (x,y)			
		lh t3,2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call VER_ATAQUE_ESQ2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels	
		
VER_ATAQUE_ESQ2:
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-32		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_ESQ		# se passar pelas 2 verificação ocorre o tiro
		
VER_ATAQUE_DIR1:la t0,CHAR_POS							
		lh t2,0(t0)		# carrega a posição do personagem (x,y)			
		lh t3,2(t0)		

		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call VER_ATAQUE_DIR2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels
		
VER_ATAQUE_DIR2:
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,32		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_DIR		# se passar pelas 2 verificação ocorre o tiro
		
VER_ATAQUE_CIMA1:la t0, CHAR_POS
		lh t2,0(t0)		# carrega a posição do personagem (x,y)					
		lh t3,2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		li t5,4			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é saída
		call VER_ATAQUE_CIMA2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels

VER_ATAQUE_CIMA2:
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-32		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		li t5,4			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é saída	
		call ATAQUE_CIMA	# se passar pelas 2 verificação ocorre o tiro
			
VER_ATAQUE_BAIXO1:la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega a posição do personagem (x,y)		
		lh t3, 2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		call VER_ATAQUE_BAIXO2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels
		
VER_ATAQUE_BAIXO2:
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,32		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_BAIXO	# se passar pelas 2 verificação ocorre o tiro
		
ATAQUE_ESQ:	la t0, CHAR_POS
		la a0,tiro_a
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o tiro 16px atrás
		lh a2, 2(t0)
		addi a1,a1,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_a
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o tiro 32px atrás
		lh a2, 2(t0)
		addi a1,a1,-32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1,a1,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)		
		lh a2, 2(t0)
		addi a1,a1,-32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_DIR:	la t0, CHAR_POS
		la a0,tiro_d
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px a frente
		lh a2, 2(t0)
		addi a1,a1,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_d
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px a frente
		lh a2, 2(t0)
		addi a1,a1,32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1,a1,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			
		lh a2, 2(t0)
		addi a1,a1,32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_CIMA:	la t0, CHAR_POS
		la a0,tiro_w
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px acima
		lh a2, 2(t0)
		addi a2,a2,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_w
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px acima
		lh a2, 2(t0)
		addi a2,a2,-32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2,a2,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			
		lh a2, 2(t0)
		addi a2,a2,-32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_BAIXO:	la t0, CHAR_POS
		la a0,tiro_s
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px abaixo
		lh a2, 2(t0)
		addi a2,a2,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_s
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px abaixo
		lh a2, 2(t0)
		addi a2,a2,32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2,a2,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px a frente
		lh a2, 2(t0)
		addi a2,a2,32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP

COLETA_CHAVE:	coleta_chave()
		j GAME_LOOP
		
COLETA_MOEDA:	coleta_moeda()
		j GAME_LOOP	
		
PRINT:		li t0,0xFF0
		add t0,t0,a3
		slli t0,t0,20
		
		add t0,t0,a1
		
		li t1,320
		mul t1,t1,a2
		add t0,t0,t1
		
		addi t1,a0,8
		
		mv t2,zero
		mv t3,zero
		
		lw t4,0(a0)
		lw t5,4(a0)
	
PRINT_LINHA:	lw t6,0(t1)
		sw t6,0(t0)
		
		addi t0,t0,4
		addi t1,t1,4
		
		addi t3,t3,4
		blt t3,t4,PRINT_LINHA
		
		addi t0,t0,320
		sub t0,t0,t4
		
		mv t3,zero
		addi t2,t2,1
		bgt t5,t2,PRINT_LINHA
		
		ret

VERIFICACAO_SAIDA:	li t5,2			# atribui o 2 que representa a quantidade de chave na fase ao t5
			beq s6,t5,SAIDA		# se o n° de chaves coletas for igual a quantidade de chaves na fase, a saída é liberada
			j GAME_LOOP

SAIDA:		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li a0,60			# nota
		li a1,1300			# duração
		li a2,55			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,62			# nota
		li a1,1250			# duração
		li a2,55			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall	
		
END:		li s5, 0 		# zerar o registrador de moedas para a próxima fase
		li s6, 0		# zerar o registrador de chaves para a próxima fase

.end_macro

.macro fase2()
.data
# MENU 
TITULO_FASE: .string "FASE 2"
PONTOS: .string "PONTOS:"
VIDAS: .string "VIDAS:"
CHAVES: .string "CHAVES:"
NUM_CHAVES: .string "/2"

# POSIÇÕES_FASE2
CHAR_POS: .half 192,208		# posição do personagem (x,y)
OLD_CHAR_POS: .half 192,208
COG1: .half 64,64
CHAVE1: .half 192,96
CHAVE2: .half 16,144
MOEDA1: .half 16,32
MOEDA2: .half 96,80
MOEDA3: .half 144,144

.text
SETUP: 		
# Carrega a matriz da fase 1 para o registrador s1
		la s1, matriz2	
		addi s1,s1,8

# Printa a imagem do mapa, alternando os frames
		la a0,ideia_fase2	
		li a1,0
		li a2,0
		li a3,0
		li a4,320
		li a4,240
		call PRINT
		li a3,1
		call PRINT
		
# Printa o título da fase, alternando os frames		
		li a7,104        	
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,0
		ecall
		li a7,104        
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,1
		ecall
		
# Adiciona a string dos pontos da fase, alternando os frames
		li a7,104        
		la a0,PONTOS       
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,0
		ecall
		li a7,104        
		la a0,PONTOS        
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,1
		ecall

# Adiciona a string de chaves da fase, alternando os frames
		li a7,104        
		la a0,CHAVES       
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,CHAVES        
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,1
		ecall
		li a7,104        
		la a0,NUM_CHAVES       
		li a1,265
		li a2,140
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,NUM_CHAVES        
		li a1,265
		li a2,140
		li a3,0x00a0
		li a4,1
		ecall

# Adiciona a string de vidas da fase, alternando os frames
		li a7,104        
		la a0,VIDAS       
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,0
		ecall
		li a7,104        
		la a0,VIDAS        
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,1
		ecall

# Printa o personagem na posição inicial, alternado os frames			
		la t3,CHAR_POS		
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		la t3,CHAR_POS	
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		
# Printa as chaves e as moedas nas posições e frames corretos para a coleta		
		la t3, CHAVE1
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,1
		call PRINT
		la t3, CHAVE2
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,1
		call PRINT
		
		la t3, MOEDA1
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, MOEDA2
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, MOEDA3
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,1
		call PRINT
		
		li s6, 0 # zerando o contador de chaves
		li s5, 0 # zerando o contador de moedas

GAME_LOOP:	call KEY
		j GAME_LOOP

KEY:		
# Faz a chamada do teclado e guarda a tecla pressionada no t2
		li t1,0xFF200000	
		lw t0,0(t1)
		andi t0,t0,0x0001
		beq t0,zero,FIM
		lw t2,4(t1)
		
# Compara as teclas para chamar a movimentação	
		li t0,'a'		
		beq t2,t0,CHAR_ESQ
		
		li t0,'d'
		beq t2,t0,CHAR_DIR
		
		li t0,'w'
		beq t2,t0,CHAR_CIMA
		
		li t0,'s'
		beq t2,t0,CHAR_BAIXO
		
		li t0,'e'
		beq t2,t0,DIRECAO_ATAQUE
		
		li t0, 'p'
		beq t2,t0,END

FIM:		ret

CHAR_ESQ:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem			
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_a
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,1				# atribui '1' ao s7 para indicar a direção (esquerda) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_DIR:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem		
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem

		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_d
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,2				# atribui '2' ao s7 para indicar a direção (direita) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_CIMA:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem				
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		li t5,4
		beq s3,t5,VERIFICACAO_SAIDA
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,3			# atribui '3' ao s7 para indicar a direção (cima) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_BAIXO:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem	
		lh t3, 2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3, 2(t1)
		sh s4,2(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_s
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,4			# atribui '4' ao s7 para indicar a direção (baixo) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

		
DIRECAO_ATAQUE:	li t6,1			# atribui o '1' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_ESQ1	# se s7 for igual, o ataque será direcionado para esquerda, mas antes é preciso verificar se é parede
		
		li t6,2			# atribui o '2' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_DIR1	# se s7 for igual, o ataque será direcionado para direita, mas antes é preciso verificar se é parede
		
		li t6,3			# atribui o '3' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_CIMA1	# se s7 for igual, o ataque será direcionado para cima, mas antes é preciso verificar se é parede
		
		li t6,4			# atribui o '4' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_BAIXO1	# se s7 for igual, o ataque será direcionado para baixo, mas antes é preciso verificar se é parede
		
		j GAME_LOOP
		
VER_ATAQUE_ESQ1:
		la t0,CHAR_POS						
		lh t2,0(t0)		# carrega a posição do personagem (x,y)			
		lh t3,2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call VER_ATAQUE_ESQ2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels	
		
VER_ATAQUE_ESQ2:
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-32		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_ESQ		# se passar pelas 2 verificação ocorre o tiro
		
VER_ATAQUE_DIR1:la t0,CHAR_POS							
		lh t2,0(t0)		# carrega a posição do personagem (x,y)			
		lh t3,2(t0)		

		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call VER_ATAQUE_DIR2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels
		
VER_ATAQUE_DIR2:
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,32		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_DIR		# se passar pelas 2 verificação ocorre o tiro
		
VER_ATAQUE_CIMA1:la t0, CHAR_POS
		lh t2,0(t0)		# carrega a posição do personagem (x,y)					
		lh t3,2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		li t5,4			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é saída
		call VER_ATAQUE_CIMA2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels

VER_ATAQUE_CIMA2:
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-32		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		li t5,4			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é saída	
		call ATAQUE_CIMA	# se passar pelas 2 verificação ocorre o tiro
			
VER_ATAQUE_BAIXO1:la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega a posição do personagem (x,y)		
		lh t3, 2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		call VER_ATAQUE_BAIXO2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels
		
VER_ATAQUE_BAIXO2:
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,32		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_BAIXO	# se passar pelas 2 verificação ocorre o tiro
		
ATAQUE_ESQ:	la t0, CHAR_POS
		la a0,tiro_a
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o tiro 16px atrás
		lh a2, 2(t0)
		addi a1,a1,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_a
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o tiro 32px atrás
		lh a2, 2(t0)
		addi a1,a1,-32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1,a1,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)		
		lh a2, 2(t0)
		addi a1,a1,-32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_DIR:	la t0, CHAR_POS
		la a0,tiro_d
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px a frente
		lh a2, 2(t0)
		addi a1,a1,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_d
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px a frente
		lh a2, 2(t0)
		addi a1,a1,32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1,a1,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			
		lh a2, 2(t0)
		addi a1,a1,32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_CIMA:	la t0, CHAR_POS
		la a0,tiro_w
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px acima
		lh a2, 2(t0)
		addi a2,a2,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_w
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px acima
		lh a2, 2(t0)
		addi a2,a2,-32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2,a2,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			
		lh a2, 2(t0)
		addi a2,a2,-32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_BAIXO:	la t0, CHAR_POS
		la a0,tiro_s
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px abaixo
		lh a2, 2(t0)
		addi a2,a2,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_s
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px abaixo
		lh a2, 2(t0)
		addi a2,a2,32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2,a2,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px a frente
		lh a2, 2(t0)
		addi a2,a2,32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
COLETA_CHAVE:	coleta_chave()
		j GAME_LOOP	
		
COLETA_MOEDA:	coleta_moeda()
		j GAME_LOOP	
		
PRINT:		li t0,0xFF0
		add t0,t0,a3
		slli t0,t0,20
		
		add t0,t0,a1
		
		li t1,320
		mul t1,t1,a2
		add t0,t0,t1
		
		addi t1,a0,8
		
		mv t2,zero
		mv t3,zero
		
		lw t4,0(a0)
		lw t5,4(a0)
	
PRINT_LINHA:	lw t6,0(t1)
		sw t6,0(t0)
		
		addi t0,t0,4
		addi t1,t1,4
		
		addi t3,t3,4
		blt t3,t4,PRINT_LINHA
		
		addi t0,t0,320
		sub t0,t0,t4
		
		mv t3,zero
		addi t2,t2,1
		bgt t5,t2,PRINT_LINHA
		
		ret

VERIFICACAO_SAIDA:	li t5,2		# atribui o 2 que representa a quantidade de chave na fase ao t5
			beq s6,t5,SAIDA	# se o n° de chaves coletas for igual a quantidade de chaves na fase, a saída é liberada
			j GAME_LOOP

SAIDA:		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li a0,60			# nota
		li a1,1300			# duração
		li a2,55			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,62			# nota
		li a1,1250			# duração
		li a2,55			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
END:		li s6,0			# zerar o registrador de chaves para próxima fase

.end_macro

.macro fase3()
.data
# MENU 
TITULO_FASE: .string "FASE 3"
PONTOS: .string "PONTOS:"
VIDAS: .string "VIDAS:"
CHAVES: .string "CHAVES:"
NUM_CHAVES: .string "/3"

# POSIÇÕES_FASE3
CHAR_POS: .half 192,96		# posição do personagem (x,y)
OLD_CHAR_POS: .half 192,96
COG1: .half 64,64
CHAVE1: .half 128,192
CHAVE2: .half 128,32
CHAVE3: .half 96,160
MOEDA1: .half 48,48
MOEDA2: .half 16,208
MOEDA3: .half 160,96

.text
SETUP: 		
# Carrega a matriz da fase 1 para o registrador s1
		la s1, matriz3	
		addi s1,s1,8

# Printa a imagem do mapa, alternando os frames
		la a0,ideia_fase3	
		li a1,0
		li a2,0
		li a3,0
		li a4,320
		li a4,240
		call PRINT
		li a3,1
		call PRINT
		
# Printa o título da fase, alternando os frames 		
		li a7,104        	
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,0
		ecall
		li a7,104        
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,1
		ecall
		
# Adiciona a string dos pontos da fase, alternando os frames
		li a7,104        
		la a0,PONTOS       
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,0
		ecall
		li a7,104        
		la a0,PONTOS        
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,1
		ecall

# Adiciona a string de chaves da fase, alternando os frames
		li a7,104        
		la a0,CHAVES       
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,CHAVES        
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,1
		ecall
		li a7,104        
		la a0,NUM_CHAVES       
		li a1,265
		li a2,140
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,NUM_CHAVES        
		li a1,265
		li a2,140
		li a3,0x00a0
		li a4,1
		ecall

# Adiciona a string de vidas da fase, alternando os frames
		li a7,104        
		la a0,VIDAS       
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,0
		ecall
		li a7,104        
		la a0,VIDAS        
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,1
		ecall

# Printa o personagem na posição inicial, alternado os frames			
		la t3,CHAR_POS	
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		la t3,CHAR_POS		
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
		
# Printa as chaves e as moedas nas posições e frames corretos para a coleta
		la t3, CHAVE1
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, CHAVE2
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, CHAVE3
		la a0, chave
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		
		la t3, MOEDA1
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, MOEDA2
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT
		la t3, MOEDA3
		la a0, moeda
		lh a1,0(t3)
		lh a2,2(t3)
		li a3,0
		call PRINT

GAME_LOOP:	call KEY
		j GAME_LOOP

KEY:		
# Faz a chamada do teclado e guarda a tecla pressionada no t2
		li t1,0xFF200000	
		lw t0,0(t1)
		andi t0,t0,0x0001
		beq t0,zero,FIM
		lw t2,4(t1)
		
# Compara as teclas para chamar a movimentação	
		li t0,'a'		
		beq t2,t0,CHAR_ESQ
		
		li t0,'d'
		beq t2,t0,CHAR_DIR
		
		li t0,'w'
		beq t2,t0,CHAR_CIMA
		
		li t0,'s'
		beq t2,t0,CHAR_BAIXO
		
		li t0,'e'
		beq t2,t0,DIRECAO_ATAQUE
		
		li t0, 'p'
		beq t2,t0,END

FIM:		ret

CHAR_ESQ:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem			
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_a
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,1				# atribui '1' ao s7 para indicar a direção (esquerda) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_DIR:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem		
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem

		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		li t5,4
		beq s3,t5,VERIFICACAO_SAIDA
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_d
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,2				# atribui '2' ao s7 para indicar a direção (direita) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_CIMA:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem				
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,3			# atribui '3' ao s7 para indicar a direção (cima) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

CHAR_BAIXO:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem	
		lh t3, 2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3, 2(t1)
		sh s4,2(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_s
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	# sobrepor o personagem com a fundo a partir da posição antiga
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li s7,4			# atribui '4' ao s7 para indicar a direção (baixo) do personagem
		
		li t5,2				# atribui o '2' que representa chave ao t5
		beq s3,t5,COLETA_CHAVE		# se a nova posição do personagem for uma chave, ocorre a coleta
		li t5,3				# atribui o '3' que representa moeda ao t5
		beq s3,t5,COLETA_MOEDA		# se a nova posição do personagem for uma moeda, ocorre a coleta
	
		j GAME_LOOP

DIRECAO_ATAQUE:	li t6,1			# atribui o '1' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_ESQ1	# se s7 for igual, o ataque será direcionado para esquerda, mas antes é preciso verificar se é parede
		
		li t6,2			# atribui o '2' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_DIR1	# se s7 for igual, o ataque será direcionado para direita, mas antes é preciso verificar se é parede
		
		li t6,3			# atribui o '3' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_CIMA1	# se s7 for igual, o ataque será direcionado para cima, mas antes é preciso verificar se é parede
		
		li t6,4			# atribui o '4' que representa direção ao t6
		beq t6,s7,VER_ATAQUE_BAIXO1	# se s7 for igual, o ataque será direcionado para baixo, mas antes é preciso verificar se é parede
		
		j GAME_LOOP
		
VER_ATAQUE_ESQ1:
		la t0,CHAR_POS						
		lh t2,0(t0)		# carrega a posição do personagem (x,y)			
		lh t3,2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call VER_ATAQUE_ESQ2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels	
		
VER_ATAQUE_ESQ2:
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-32		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4		
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_ESQ		# se passar pelas 2 verificação ocorre o tiro
		
VER_ATAQUE_DIR1:la t0,CHAR_POS							
		lh t2,0(t0)		# carrega a posição do personagem (x,y)			
		lh t3,2(t0)		

		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call VER_ATAQUE_DIR2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels
		
VER_ATAQUE_DIR2:
		# Procedimentos para verificação de parede
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,32		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_DIR		# se passar pelas 2 verificação ocorre o tiro
		
VER_ATAQUE_CIMA1:la t0, CHAR_POS
		lh t2,0(t0)		# carrega a posição do personagem (x,y)					
		lh t3,2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		li t5,4			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é saída
		call VER_ATAQUE_CIMA2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels

VER_ATAQUE_CIMA2:
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-32		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		li t5,4			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é saída	
		call ATAQUE_CIMA	# se passar pelas 2 verificação ocorre o tiro
			
VER_ATAQUE_BAIXO1:la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega a posição do personagem (x,y)		
		lh t3, 2(t0)		
		
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede 
		call VER_ATAQUE_BAIXO2	# próxima verificação, pois o tiro tem range de 2 casas = 32 pixels
		
VER_ATAQUE_BAIXO2:
		# Procedimentos para verificação de parede
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,32		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5		# cálculo para chegar ao endereço da matriz correspondente a posição do personagem
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,GAME_LOOP	# compara se a nova posição do personagem é parede
		call ATAQUE_BAIXO	# se passar pelas 2 verificação ocorre o tiro
		
ATAQUE_ESQ:	la t0, CHAR_POS
		la a0,tiro_a
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o tiro 16px atrás
		lh a2, 2(t0)
		addi a1,a1,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_a
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o tiro 32px atrás
		lh a2, 2(t0)
		addi a1,a1,-32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1,a1,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)		
		lh a2, 2(t0)
		addi a1,a1,-32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_DIR:	la t0, CHAR_POS
		la a0,tiro_d
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px a frente
		lh a2, 2(t0)
		addi a1,a1,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_d
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px a frente
		lh a2, 2(t0)
		addi a1,a1,32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1,a1,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			
		lh a2, 2(t0)
		addi a1,a1,32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_CIMA:	la t0, CHAR_POS
		la a0,tiro_w
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px acima
		lh a2, 2(t0)
		addi a2,a2,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_w
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px acima
		lh a2, 2(t0)
		addi a2,a2,-32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2,a2,-16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			
		lh a2, 2(t0)
		addi a2,a2,-32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
ATAQUE_BAIXO:	la t0, CHAR_POS
		la a0,tiro_s
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px abaixo
		lh a2, 2(t0)
		addi a2,a2,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,tiro_s
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 32px abaixo
		lh a2, 2(t0)
		addi a2,a2,32
		mv a3,s0
		call PRINT
		
		# som de tiro
		li a0,50			# nota
		li a1,1000			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,85			# nota
		li a1,300			# duração
		li a2,127			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Pausa para apagar o rastro do tiro
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,0				# nota
		li a1,2000000000		# duração
		li a2,0				# define o instrumento
		li a3,0				# define o volume
		li a7,31			# define a syscall
		ecall
		
		# Procedimentos para apagar o rastro do tiro
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2,a2,16
		mv a3,s0
		call PRINT
		la t0, CHAR_POS
		la a0,fundo
		lh a1, 0(t0)			# Recebe as posicoes do personagem nos dois frames para imprimir o raio 16px a frente
		lh a2, 2(t0)
		addi a2,a2,32
		mv a3,s0
		call PRINT
		
		j GAME_LOOP
		
COLETA_CHAVE:	coleta_chave()
		j GAME_LOOP	
		
COLETA_MOEDA:	coleta_moeda()
		j GAME_LOOP	
		
PRINT:		li t0,0xFF0
		add t0,t0,a3
		slli t0,t0,20
		
		add t0,t0,a1
		
		li t1,320
		mul t1,t1,a2
		add t0,t0,t1
		
		addi t1,a0,8
		
		mv t2,zero
		mv t3,zero
		
		lw t4,0(a0)
		lw t5,4(a0)
	
PRINT_LINHA:	lw t6,0(t1)
		sw t6,0(t0)
		
		addi t0,t0,4
		addi t1,t1,4
		
		addi t3,t3,4
		blt t3,t4,PRINT_LINHA
		
		addi t0,t0,320
		sub t0,t0,t4
		
		mv t3,zero
		addi t2,t2,1
		bgt t5,t2,PRINT_LINHA
		
		ret

VERIFICACAO_SAIDA:	li t5,3		# atribui o 2 que representa a quantidade de chave na fase ao t5
			beq s6,t5,SAIDA	# se o n° de chaves coletas for igual a quantidade de chaves na fase, a saída é liberada
			j GAME_LOOP

SAIDA:		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
		
		li a0,60			# nota
		li a1,1300			# duração
		li a2,55			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall
		li a0,62			# nota
		li a1,1250			# duração
		li a2,55			# define o instrumento
		li a3,127			# define o volume
		li a7,31			# define a syscall
		ecall

END:		li s6,0			# zerar o registrador de chaves para próxima fase

.end_macro

.macro fim()
.data
TAMANHO: 18
NOTAS: 60,1000,59,316,60,316,59,632,55,948,52,316,57,632,52,1264,60,1580
.text
	la s0,TAMANHO		# define o endereço do número de notas
	lw s1,0(s0)		# le o numero de notas
	la s0,NOTAS		# define o endereço das notas
	li t0,0			# zera o contador de notas
	li a2,1         	# define o instrumento
	li a3,127		# define o volume


LOOP:	beq t0, s1, FIM
	lw a0, 0(s0)
	lw a1, 4(s0)
	li a7, 31	# syscall para tocar a nota
	ecall
	mv a0, a1 	# passa a duração da nota para a0 a fim de executar a pausa
	li a7, 32	# executa a pausa
	ecall
	addi s0, s0, 8	# incrementando s0 a fim de chegar à próxima nota
	addi t0, t0, 1  # incrementando o contador
	j LOOP

FIM: 	li a7,10
	ecall
	
.end_macro

####################################
#		MAIN		   #
####################################

.text
ABERTURA:
# Printa a imagem de abertura
		la a0,tema_jogo_imagem.bmp2
		li a1,0
		li a2,0
		li a3,0
		call PRINT
		li a3,1
		call PRINT
# Música da abertura
		la a4,TAMANHO		# define o endereço do número de notas
		lw a5,0(a4)		# le o numero de notas
		la a4,NOTAS		# define o endereço das notas
		li t0,0			# zera o contador de notas
		li a2,24		# define o instrumento
		li a3,127		# define o volume
	
# Faz a verificação se alguma tecla está pressionada	
VERIFICAÇÃO:    li t1,0xFF200000
		lw t0,0(t1)
		andi t0,t0,0x0001
		beq t0,zero,LOOP
		lw t2,4(t1)

		li t0,'q'
		beq t2,t0,GAME
restart: 	la a4,TAMANHO		# define o endereço do número de notas
		lw a5,0(a4)		# le o numero de notas
		la a4,NOTAS		# define o endereço das notas
		li t0,0			# zera o contador de notas
		li a2,24		# define o instrumento
		li a3,127		# define o volume
		li a6, 0
		j VERIFICAÇÃO
LOOP:		beq a6,a5,restart		# contador chegou no final? então volte para o inicio da música
		lw a0,0(a4)		# le o valor da nota
		lw a1,4(a4)		# le a duracao da nota
		li a7,31		# define a chamada de syscall
		ecall			# toca a nota
		mv a0,a1		# passa a duração da nota para a pausa
		li a7,32		# define a chamada de syscall 
		ecall			# realiza uma pausa de a0 ms
		addi a4,a4,8		# incrementa para o endereço da próxima nota
		addi a6,a6,1		# incrementa o contador de notas
		j VERIFICAÇÃO		# volta ao loop

				
GAME:		fase1()
		fase2()
		fase3()
		j FINAL
		fim()

FINAL:		la a0,final	
		li a1,0
		li a2,0
		li a3,0
		li a4,320
		li a4,240
		call PRINT
		li a3,1
		call PRINT
		ret
		
PRINT:		li t0,0xFF0
		add t0,t0,a3
		slli t0,t0,20
		
		add t0,t0,a1
		
		li t1,320
		mul t1,t1,a2
		add t0,t0,t1
		
		addi t1,a0,8
		
		mv t2,zero
		mv t3,zero
		
		lw t4,0(a0)
		lw t5,4(a0)
	
PRINT_LINHA:	lw t6,0(t1)
		sw t6,0(t0)
		
		addi t0,t0,4
		addi t1,t1,4
		
		addi t3,t3,4
		blt t3,t4,PRINT_LINHA
		
		addi t0,t0,320
		sub t0,t0,t4
		
		mv t3,zero
		addi t2,t2,1
		bgt t5,t2,PRINT_LINHA
		
		ret
.include "SYSTEMv21.s"
