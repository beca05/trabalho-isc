.include "MACROSv21.s"

.data
# ABERTURA
.include "tema_jogo_imagem.bmp2.data"
# MÚSICA ABERTURA
TAMANHO: .word 37
NOTAS: 60,441,64,441,60,1764,64,294,64,294,65,441,64,441,62,294,60,294,62,441,64,441,62,1764,62,294,62,294,62,294,64,294,62,294,60,588,60,441,64,441,60,1764,64,294,64,294,65,441,64,294,62,441,60,294,62,441,64,441,62,1764,62,294,62,294,62,147,64,294,62,441,60,294,53,294

# MAPA
.include "ideia_fase1.data"
.include "fundo.data"
.include "porta_ws.data"
.include "porta_ad.data"
.include "matriz1.s"


# PERSONAGEM PRINCIPAL
.include "personagem_a.data"
.include "personagem_d.data"
.include "personagem_w.data"
.include "personagem_s.data"

# INIMIGO
.include "cogumelo_s.data"
.include "cogumelo_w.data"
.include "cogumelo_a.data"
.include "cogumelo_d.data"
.include "ervilha_a.data"
.include "ervilha_d.data"

# ITENS
.include "chave.data"
.include "moeda.data"

# MENU 
TITULO_FASE: .string "FASE 1"
PONTOS: .string "PONTOS:"
VIDAS: .string "VIDAS:"

# POSIÇÕES
CHAR_POS: .half 16,16		# posição do personagem (x,y)
OLD_CHAR_POS: .half 16,16
COG1: .half 64,64
CHAVE1: .half 192,96
CHAVE2: .half 64,160
MOEDA1: .half 112,16
#MOEDA2: .half 32,208
PORTA1: .half 16,112
PORTA2: .half 128,96

.text
ABERTURA:
# Printa a imagem de abertura
		la a0,tema_jogo_imagem.bmp2
		li a1,0
		li a2,0
		li a3,0
		call PRINT
		li a3,1
		call PRINT
# Música da abertura
	la s0,TAMANHO		# define o endereço do número de notas
	lw s1,0(s0)		# le o numero de notas
	la s0,NOTAS		# define o endereço das notas
	li t0,0			# zera o contador de notas
	li a2,24		# define o instrumento
	li a3,127		# define o volume
	
# Faz a verificação se alguma tecla está pressionada	
VERIFICAÇÃO:    li t1,0xFF200000
		lw t0,0(t1)
		andi t0,t0,0x0001
		beq t0,zero,LOOP
		lw t2,4(t1)
	
	li t0,'q'
	beq t2,t0,SETUP

LOOP:	beq t0,s1,SETUP		# contador chegou no final? então  vá para setup
	lw a0,0(s0)		# le o valor da nota
	lw a1,4(s0)		# le a duracao da nota
	li a7,31		# define a chamada de syscall
	ecall			# toca a nota
	mv a0,a1		# passa a duração da nota para a pausa
	li a7,32		# define a chamada de syscall 
	ecall			# realiza uma pausa de a0 ms
	addi s0,s0,8		# incrementa para o endereço da próxima nota
	addi t0,t0,1		# incrementa o contador de notas
	j VERIFICAÇÃO			# volta ao loop

SETUP: 		
# Carrega a matriz da fase 1 para o registrador s1
		la s1, matriz1		
		addi s1,s1,8

# Printa a imagem do mapa, alternando os frames
		la a0,ideia_fase1	
		li a1,0
		li a2,0
		li a3,0
		li a4,320
		li a4,240
		call PRINT
		li a3,1
		call PRINT
		
		li a7,104        	# printa o título da fase 
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,0
		ecall
		li a7,104        
		la a0,TITULO_FASE        
		li a1,252
		li a2,9 
		li a3,0x00FF
		li a4,1
		ecall
		
		la t3,CHAR_POS		# printa o personagem na posição inicial
		la a0,personagem_s
		lh a1,0(t3)
		lh a2,2(t3)
		mv a3,s0
		call PRINT
	
# Adiciona a string dos pontos da fase
		li a7,104        
		la a0,PONTOS       
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,0
		ecall
		li a7,104        
		la a0,PONTOS        
		li a1,250
		li a2,50 
		li a3,0x0090
		li a4,1
		ecall

# Adiciona a string de chaves da fase
		li a7,104        
		la a0,CHAVES       
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,0
		ecall
		li a7,104        
		la a0,CHAVES        
		li a1,250
		li a2,110 
		li a3,0x00a0
		li a4,1
		ecall

# Adiciona a string de vidas da fase
		li a7,104        
		la a0,VIDAS       
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,0
		ecall
		li a7,104        
		la a0,VIDAS        
		li a1,252
		li a2,170 
		li a3,0x00b0
		li a4,1
		ecall
		

GAME_LOOP:	call KEY


KEY:		
# Faz a chamada do teclado e guarda a tecla pressionada no t2
		li t1,0xFF200000	
		lw t0,0(t1)
		andi t0,t0,0x0001
		beq t0,zero,FIM
		lw t2,4(t1)
		
# Compara as teclas para chamar a movimentação	
		li t0,'a'		
		beq t2,t0,CHAR_ESQ
		
		li t0,'d'
		beq t2,t0,CHAR_DIR
		
		li t0,'w'
		beq t2,t0,CHAR_CIMA
		
		li t0,'s'
		beq t2,t0,CHAR_BAIXO

FIM:		ret

CHAR_ESQ:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem			
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,-16		# subtrai 16 do x para andar para esquerda
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_a
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
	
		j GAME_LOOP

CHAR_DIR:	la t0,CHAR_POS				
		la t1,OLD_CHAR_POS			
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem		
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem

		
		lh s4,0(t0)		# carrega o x para o registrador s4
		addi s4,s4,16		# soma 16 ao x para andar para direita
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul s2,t3,t5
		add s2,s1,s2
		add s2,s2,s4
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,0(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_d
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
	
		li t0,0xFF200604
		sw s0,0(t0)
	
		j GAME_LOOP

CHAR_CIMA:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem				
		lh t3,2(t0)		# carrega em t3 o y da posição do personagem
		
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,-16		# subtrai 16 do y para andar para cima
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3,2(t1)
		sh s4,2(t0)

		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_w
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
	
		j GAME_LOOP

CHAR_BAIXO:	la t0, CHAR_POS
		la t1, OLD_CHAR_POS
		lh t2,0(t0)		# carrega em t2 o x da posição do personagem	
		lh t3, 2(t0)		# carrega em t3 o y da posição do personagem
		
		lh s4,2(t0)		# carrega o y para o registrador s4
		addi s4,s4,16		# soma 16 ao y para andar para baixo
		li t5,320		# atribui 320 ao t5 para fazer o cálculo do endereço da posição do personagem na matriz
		mul t5,s4,t5
		add s2,s1,t5
		add s2,s2,t2
		lb s3,0(s2)
		li t5,1			# atribui o '1' que representa parede ao t5
		beq s3,t5,FIM		# compara se a nova posição do personagem é parede ou chão, se for parede o programa retorna sem executar a movimentação
		
		sh t2,0(t1)		# se for chão, vai atualizar a posição antiga do personagem
		sh t3, 2(t1)
		sh s4,2(t0)
		
		xori s0,s0,1 		# alterna os frames
								
		la t0,CHAR_POS		# carrega a sprite e a posição para printar	
		la a0,personagem_s
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		li a4,16		# largura do personagem
		li a5,16		# altura do personagem
		call PRINT
		
		la t0,OLD_CHAR_POS	#t0 guarda a posicao antiga do personagem
		la a0,fundo
		lh a1,0(t0)
		lh a2,2(t0) 
		mv a3,s0
		xori a3,a3,1
		call PRINT
		
		li t0,0xFF200604
		sw s0,0(t0)
	
		j GAME_LOOP
		
PRINT:		li t0,0xFF0
		add t0,t0,a3
		slli t0,t0,20
		
		add t0,t0,a1
		
		li t1,320
		mul t1,t1,a2
		add t0,t0,t1
		
		addi t1,a0,8
		
		mv t2,zero
		mv t3,zero
		
		lw t4,0(a0)
		lw t5,4(a0)
	
PRINT_LINHA:	lw t6,0(t1)
		sw t6,0(t0)
		
		addi t0,t0,4
		addi t1,t1,4
		
		addi t3,t3,4
		blt t3,t4,PRINT_LINHA
		
		addi t0,t0,320
		sub t0,t0,t4
		
		mv t3,zero
		addi t2,t2,1
		bgt t5,t2,PRINT_LINHA
		
		ret
		
.include "SYSTEMv21.s"
